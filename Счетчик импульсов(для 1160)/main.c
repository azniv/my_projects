//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Счетчик импульсов для пульта 1160 
// MCU ATMEGA48P
// F_CPU 12 либо 16 MHz
// Дата крайнего редактирования 27.11.2015
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <avr/io.h>
#include <avr/interrupt.h>
#include <util/delay.h>
#include "configuration.h"

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Глобальные переменные
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

volatile uint16_t pulses         = 0;  // Количество подсчитанных импульсов
volatile uint8_t  overflow_flag  = 0;  // Превышение максимального значения индикатора (>999)
volatile uint8_t  stage_of_count = 0;  // Стадии отсчета (2 - начало нового цикла каждые 0.5-2 сек, 
                                       // 1 - начало отсчета после первого импульса,
                                       // 0 - конец отсчета после второго импульса)

// Массив цифр 0..9 для вывода на семисегментные индикаторы
const uint8_t numbers[] = {NUM_0, NUM_1, NUM_2, NUM_3, NUM_4, NUM_5, NUM_6, NUM_7, NUM_8, NUM_9}; 

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Прерывания от таймеров
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Прерывание срабатывает 1 раз в секунду
ISR(TIMER0_OVF_vect) {
    static uint8_t t0;
    static uint8_t t3sec;
    
    if (!(t0--)) {
        t0 = (F_CPU/1024/256)&0xFF;
        cli();
        //Подаем отрицательные импульсы длительностью 10 мкс с частотой 3 с
        if (!(t3sec--)) {
            PORTC &= ~(1<<4);
            _delay_us(10);
            PORTC |= (1<<4);        
            t3sec = 2;
        }
        sei();
        stage_of_count = 2;
    }
}

// Прерывание срабатывает через 32 мс при 16MHz либо через 43мс при 12MHz после прихода первого импульса
ISR(TIMER1_OVF_vect) {
    if ((stage_of_count==1) && BUTTON_CTRL_IS_RELEASED) {
        pulses = 999;
        overflow_flag = 1;
    }
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Прерывания от PCINT (кнопки, импульсы)
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Нажата кнопка "Контроль"
ISR(PCINT0_vect) {
    if (BUTTON_CTRL_IS_PRESSED) {
        pulses = 0;
        overflow_flag = 0;
        stage_of_count = 0;
    }
}    

// Подсчет количества импульсов длительностью 10 мкс от T3(контакта1)
ISR(PCINT1_vect) {
    // все импульсы обрабатываем по падающему фронту
    if (~PINC & (1<<3)) {
        
        // Старт нового отсчета 
        if (stage_of_count && BUTTON_CTRL_IS_RELEASED) {
            if (stage_of_count == 2) {
                TCNT1 = 0;
                pulses = 0 ;    
                overflow_flag = 0;
            }
            else {
                pulses = TCNT1/((F_CPU/800000)&0xFF);  // 800000 = (число тиков в интервале в 10 мкс) x (делитель таймера на 8)
                if ((pulses > 999) || overflow_flag) {
                    pulses = 999;
                    overflow_flag = 1;
                }                
            }

            if (--stage_of_count);
        }
        
        //Подсчет контрольных имульсов при нажатой кнопке "Контроль"
        if (BUTTON_CTRL_IS_PRESSED) {
            pulses++;
        }
    }
}    

    
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Инициализация
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline void init(void) {

    DDRD  = 0xFF;     
    PORTD = 0xFF;

    // Аноды индикатора и вывод для сигнала "3сек"
    DDRC  = (1<<DIG_HI)|(1<<DIG_MD)|(1<<DIG_LO)|(1<<4);
    
    // Вход импульсов подтянут к питанию для защиты от помех и выход 
    // для подсчета отрицательных импульсов с частотой 3 с
    PORTC = (1<<4);  
    
    // Подтягиваем кнопку "Контроль" 
    DDRB &= ~(1<<0);        
    PORTB |= (1<<0);    
    
    TIMSK0 |= (1<<TOIE0);
    TIMSK1 |= (1<<TOIE1);
    
    //Выбор частоты синхронизации TIMER0 с предделителем  1024 
    TCCR0B  = (1<<CS02)|(1<<CS00);
    
    //Выбор частоты синхронизации TIMER1 с предделителем 8
    TCCR1B  = (1<<CS11);
    
    PCICR  |= (1<<PCIE1)|(1<<PCIE0);
    PCMSK0 |= (1<<PCINT0);
    PCMSK1 |= (1<<PCINT11)|(1<<PCINT12);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Самоконтроль индикаторов
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline static void self_test(void) {
    // Зажгли все разряды
    PORTC &= ~((1<<DIG_HI)|(1<<DIG_MD)|(1<<DIG_LO));
    
    // Вывели цифры от 9 до 0
    uint8_t i = 10;
    while(i){
        i--;
        PORTD = numbers[i];
        _delay_ms(300);
        
        PORTD |=0xFF;
        _delay_ms(300);    
    }    

    // Погасили все разряды            
    PORTC |= ((1<<DIG_HI)|(1<<DIG_MD)|(1<<DIG_LO));

    // Отобразили тире и точку
    PORTD &= ~((1<<SEG_G)|(1<<SEG_DP));
    
    PORTC &= ~(1<<DIG_HI);            
    _delay_ms(200);
    PORTC |=(1<<DIG_HI);
        
    PORTC &= ~(1<<DIG_MD);
    _delay_ms(200);
    PORTC |= (1<<DIG_MD);
    
    PORTC &= ~(1<<DIG_LO);    
    _delay_ms(200);
    PORTC |= (1<<DIG_LO);
    
    _delay_ms(300);
}
    
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Вывод трехразрядного числа
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline static void indication(void) {

    //старший разряд числа 
    
    PORTD = numbers[pulses%1000/100];  
    PORTD &= ~(overflow_flag<<SEG_DP);
    PORTC &= ~(1<<DIG_HI);            
    _delay_ms(MS);
    PORTC |=(1<<DIG_HI);
    
    //средний разряд числа 
    PORTD = numbers[pulses%100/10];    
    PORTC &= ~(1<<DIG_MD);
    _delay_ms(MS);
    PORTC |= (1<<DIG_MD);

    //младший разряд числа 
    PORTD = numbers[pulses % 10];    
    //вывод точки при переполнении
     PORTC &= ~(1<<DIG_LO);    
    _delay_ms(MS);
    PORTC |= (1<<DIG_LO);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Точка входа
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

int main(void) {
    init();
    
    if (BUTTON_CTRL_IS_PRESSED)
        self_test();

    sei();
    
    while(1) {
        indication();        
    }
}
